# -*- coding: utf-8 -*-
"""Decorators-part2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Mz8GSM04K1fEz6TKTUe9qlpfiWZy1rAO

# Python Decorators - Part 2

## Recap from previous part - a simple decorator
"""

def greeting_decorator(other_func):

    def greeting_func():
        print(f"\n---------------------------------------\n"
              f"Hello!\nWelcome to function {other_func.__name__}!\n"
              f"---------------------------------------\n")
        # Note we call the function we received as parameter
        # inside our inner function
        other_func()
        print(f"\n---------------------------------------\n"
              f"Good-bye!\nThanks for using function {other_func.__name__}!"
              f"\n---------------------------------------\n")

    return greeting_func

def sum_of_digits():
  num = int(input(f"Insert a number: "))
  digits_sum = 0
  while num != 0:
    digits_sum += num % 10
    num = num // 10
  print(f"The sum of digits is: {digits_sum}")

sum_of_digits()

@greeting_decorator
def sum_of_digits():
  num = int(input(f"Insert a number: "))
  digits_sum = 0
  while num != 0:
    digits_sum += num % 10
    num = num // 10
  print(f"The sum of digits is: {digits_sum}")

sum_of_digits()

"""## Decorating functions that receive parameters and return values

Lets rewrite sum_of_digits function to receive a number as parameter (rather than getting it from the user) and to return sum of digits rather than printing it
"""

def sum_of_digits(num):
  digits_sum = 0
  while num != 0:
    digits_sum += num % 10
    num = num // 10
  return digits_sum

sum_of_digits(273)

"""There is a problem with our decorator now..."""

@greeting_decorator
def sum_of_digits(num):
  digits_sum = 0
  while num != 0:
    digits_sum += num % 10
    num = num // 10
  return digits_sum

# sum_of_digits = greeting_decorator(sum_of_digits)

sum_of_digits(384)

"""Lets rewrite our decorator to receive value as parameter and return value"""

def greeting_decorator(other_func):

    # Note: now greeting_func receives a parameter
    def greeting_func(num):
        
        print(f"\n---------------------------------------\n"
              f"Hello!\nWelcome to function {other_func.__name__}!\n"
              f"---------------------------------------\n")
        
        # Return value from the other_func is stored in a temp variable
        # to be returned later, after printing the good-bye message
        result = other_func(num)
        
        print(f"\n---------------------------------------\n"
              f"Good-bye!\nThanks for using function {other_func.__name__}!"
              f"\n---------------------------------------\n")
        
        # Note: greeting_func returns a value!
        return result

    return greeting_func

@greeting_decorator
def sum_of_digits(num):
  digits_sum = 0
  while num != 0:
    digits_sum += num % 10
    num = num // 10
  return digits_sum

ret_sum = sum_of_digits(345)
print(f"Sum of digits for 345 is: {ret_sum}")

"""Lets rewrite our decorator in a generic manner"""

def greeting_decorator(other_func):

    def greeting_func(*args, **kwargs):
        print(f"\n---------------------------------------\n"
              f"Hello!\nWelcome to function {other_func.__name__}!\n"
              f"---------------------------------------\n")
        # Note we call the function we received as parameter
        # inside our inner function
        result = other_func(*args, **kwargs)
        print(f"\n---------------------------------------\n"
              f"Good-bye!\nThanks for using function {other_func.__name__}!"
              f"\n---------------------------------------\n")
        return result

    return greeting_func

"""Double-check the decorator with another amount of arguments..."""

@greeting_decorator
def sum_and_diff(num1, num2, verbose=False):
  ret_val = num1+num2, num1-num2
  if verbose:
    print(f"The result is: {ret_val}")
  return ret_val

results = sum_and_diff(5, 6, verbose=True)

# Decorator template
def my_decorator(other_func):

    # Include *args, **kwargs in the signature
    def decorated_func(*args, **kwargs):
        
        # Optionally do some stuff before calling the original function

        # IMPORTANT! Call the original function passing it *args, **kwargs
        result = other_func(*args, **kwargs)
        
        # Optionally do some stuff after calling the original function

        # IMPORTANT! Don't forget to return the result of the original function
        return result

    # Return the function you created
    return decorated_func

"""## Exercise - Implement a decorator
Implement a decorator performance_log that prints amount of time that takes to function to complete execution.
Test your decorator with the functions provided below

*Hint: use [time.perf_counter()](https://docs.python.org/3/library/time.html#time.perf_counter) to measure time*
"""

import time

# Implement this
def performance_log(func):
  pass


@performance_log
def long_running_func(num, iters):
  val = 1
  for i in range(iters):
    val *= num
  return val

"""### Example outputs"""

long_running_func(17, 1000)

long_running_func(17, 10000)

long_running_func(17, 100000)

"""### Solution"""

import time

def performance_log(func):
  
  def decorator(*args, **kwargs):

    start = time.perf_counter()
    result = func(*args, **kwargs)
    end = time.perf_counter()
    print(f"Execution time is: {end-start}")
    return result

  return decorator

@performance_log
def long_running_func(num, iters):
  val = 1
  for i in range(iters):
    val = val * num
  return val

long_running_func(17, 1000)

long_running_func(17, 10000)

long_running_func(17, 100000)

"""## Passing parameters to decorators

Lets improve our performance_log decorator by providing it an option to log time in various units (seconds, mili-seconds or nano-seconds)
"""

@performance_log(time_units="ms")
def long_running_func(num, iters):
  val = 0
  for i in range(iters):
    val *= num
  return val

@performance_log(time_units="ns")
def sum_and_diff(num1, num2, verbose=False):
  ret_val = num1+num2, num1-num2
  if verbose:
    print(f"The result is: {ret_val}")
  return ret_val

long_running_func = performance_log(time_units="ms")(long_running_func)

# this should return a function that receives another function 
# and returns a decorated original function
def performance_log(time_units):
  
  # lets create one
  def wrapper(func):

    def decorator(*args, **kwargs):
      
      # code that calls func received as param
      pass

    # returning our decorator  
    return decorator
  
  # now lets return one
  return wrapper

#calling the line below should return a function 
#that receives funciton and return a function
@performance_log(time_units="value") 
def some_function():
  pass

import time

def performance_log(time_units='s'):

  def wrapper(func):
  
    def decorator(*args, **kwargs):

      time_func = time.perf_counter if time_units != 'ns' else time.perf_counter_ns

      start = time_func()
      result = func(*args, **kwargs)
      end = time_func()
      exec_time = end - start
      if time_units == 'ms':
        exec_time *= 1000
      print(f"Execution time is: {exec_time}")
      return result

    return decorator
  
  return wrapper

@performance_log('ms')
def long_running_func(num, iters):
  val = 1
  for i in range(iters):
    val *= num
  return val

long_running_func(35, 1000)

@performance_log('s')
def long_running_func(num, iters):
  val = 1
  for i in range(iters):
    val *= num
  return val

long_running_func(35, 1000)

@performance_log(time_units="ns")
def sum_and_diff(num1, num2, verbose=False):
  ret_val = num1+num2, num1-num2
  if verbose:
    print(f"The result is: {ret_val}")
  return ret_val

sum_and_diff(23,4)

"""## Implementing decorators inside class + Exercise 2

There is BankApplication class. It implements 3 methods - withdraw(), deposit(), feedback().

We want to make sure that critical methods withdraw() and deposit() are only called during working hours of the bank, while non-critical method feedback() might be called anytime.

Implement decorator working_hours_only that should validate that method is called during working hours only.

See Output example below.
"""

import datetime
class Bank:

  def __init__(self, bank_name):
    self.name = bank_name

  '''
    Perform validation that the operation is being performed
    during working hours only: Sun - Thu, 09:00 - 17:00
  '''
  def working_hours_only(callable):

    def wrapped_callable(*args, **kwargs):
        pass

    return wrapped_callable
  
  @working_hours_only
  def withdraw(self, amount):
    print("Called withdraw", amount)
    return amount

  @working_hours_only
  def deposit(self, amount):
    print("Called deposit")

  def feedback(self, fedback_text):
    print("Called feedback")

"""### Output example when calling two method on Saturday should look as follows.

*   feedback() should reach the method and print "Called feedback"
*   withdraw() should raise an exception "Outside working hours"


"""

bank = Bank("My Bank")

# this call should reach the funciton when outside working hours
bank.feedback("very good bank")

# this call should not reach the function when outside working hours
bank.withdraw(300)

"""### Solution"""

import datetime
class Bank:

  def __init__(self, bank_name):
    self.name = bank_name

  '''
    Perform validation that the operation is being performed
    during working hours only: Sun - Thu, 09:00 - 17:00
  '''
  def working_hours_only(callable):

    def wrapped_callable(*args, **kwargs):
      x = datetime.datetime.today()
      if x.strftime("%a") in ['Sun','Mon','Tue','Wed','Thu'] and 17 > int(x.strftime("%H")) > 9 :
        ret_val = callable(*args, **kwargs)
        return ret_val
      else:
        raise Exception("Outside working hours")

    return wrapped_callable

  
  @working_hours_only
  def withdraw(self, amount):
    print("Called withdraw", amount)
    return amount

  @working_hours_only
  def deposit(self, amount):
    print("Called deposit")

  def feedback(self, fedback_text):
    print("Called feedback")

"""### Exercise 3 - Bonus

Change your implementation of working_hours_only decorator to receive bank working days and hours as parameters.
"""

# Implement your solution